-- Enable pgvector and Create Embeddings Schema
CREATE EXTENSION IF NOT EXISTS vector;
CREATE TABLE IF NOT EXISTS document_chunks (id uuid PRIMARY KEY DEFAULT gen_random_uuid(), document_id uuid NOT NULL REFERENCES documents(id) ON DELETE CASCADE, chunk_index integer NOT NULL, content text NOT NULL, char_count integer NOT NULL, token_count integer, metadata jsonb DEFAULT '{}'::jsonb, created_at timestamptz DEFAULT now(), updated_at timestamptz DEFAULT now(), UNIQUE(document_id, chunk_index));
CREATE TABLE IF NOT EXISTS chunk_embeddings (id uuid PRIMARY KEY DEFAULT gen_random_uuid(), chunk_id uuid NOT NULL REFERENCES document_chunks(id) ON DELETE CASCADE, embedding vector(384) NOT NULL, model_name text NOT NULL DEFAULT 'nomic-embed-text', model_version text NOT NULL DEFAULT 'v1.5', created_at timestamptz DEFAULT now(), UNIQUE(chunk_id));
ALTER TABLE document_chunks ENABLE ROW LEVEL SECURITY;
ALTER TABLE chunk_embeddings ENABLE ROW LEVEL SECURITY;
CREATE INDEX IF NOT EXISTS idx_document_chunks_document_id ON document_chunks(document_id);
CREATE INDEX IF NOT EXISTS idx_document_chunks_chunk_index ON document_chunks(document_id, chunk_index);
CREATE INDEX IF NOT EXISTS idx_chunk_embeddings_chunk_id ON chunk_embeddings(chunk_id);
CREATE INDEX IF NOT EXISTS idx_chunk_embeddings_embedding_hnsw ON chunk_embeddings USING hnsw (embedding vector_cosine_ops) WITH (m = 16, ef_construction = 64);
CREATE OR REPLACE FUNCTION search_similar_chunks(query_embedding vector(384), match_threshold float DEFAULT 0.5, match_count integer DEFAULT 10, filter_document_ids uuid[] DEFAULT NULL) RETURNS TABLE(chunk_id uuid, document_id uuid, content text, similarity float, metadata jsonb) AS $$ BEGIN RETURN QUERY SELECT dc.id as chunk_id, dc.document_id, dc.content, 1-(ce.embedding<=>query_embedding) as similarity, dc.metadata FROM chunk_embeddings ce JOIN document_chunks dc ON dc.id=ce.chunk_id WHERE (filter_document_ids IS NULL OR dc.document_id=ANY(filter_document_ids)) AND 1-(ce.embedding<=>query_embedding)>match_threshold ORDER BY ce.embedding<=>query_embedding LIMIT match_count; END; $$ LANGUAGE plpgsql STABLE;
CREATE OR REPLACE FUNCTION get_document_chunks(p_document_id uuid) RETURNS TABLE(chunk_id uuid, chunk_index integer, content text, char_count integer, has_embedding boolean, metadata jsonb) AS $$ BEGIN RETURN QUERY SELECT dc.id as chunk_id, dc.chunk_index, dc.content, dc.char_count, EXISTS(SELECT 1 FROM chunk_embeddings ce WHERE ce.chunk_id=dc.id) as has_embedding, dc.metadata FROM document_chunks dc WHERE dc.document_id=p_document_id ORDER BY dc.chunk_index; END; $$ LANGUAGE plpgsql STABLE;
CREATE OR REPLACE FUNCTION estimate_token_count(text_content text) RETURNS integer AS $$ BEGIN RETURN CEIL(LENGTH(text_content)/4.0)::integer; END; $$ LANGUAGE plpgsql IMMUTABLE;
CREATE OR REPLACE FUNCTION chunk_document_text(p_document_id uuid, p_text_content text, p_chunk_size integer DEFAULT 1000, p_overlap integer DEFAULT 200) RETURNS integer AS $$ DECLARE v_chunk_count integer:=0; v_text_length integer; v_position integer:=1; v_chunk_text text; v_chunk_end integer; BEGIN DELETE FROM document_chunks WHERE document_id=p_document_id; v_text_length:=LENGTH(p_text_content); WHILE v_position<=v_text_length LOOP v_chunk_end:=LEAST(v_position+p_chunk_size-1,v_text_length); v_chunk_text:=SUBSTRING(p_text_content FROM v_position FOR(v_chunk_end-v_position+1)); INSERT INTO document_chunks(document_id,chunk_index,content,char_count,token_count,metadata) VALUES(p_document_id,v_chunk_count,v_chunk_text,LENGTH(v_chunk_text),estimate_token_count(v_chunk_text),jsonb_build_object('start_pos',v_position,'end_pos',v_chunk_end)); v_chunk_count:=v_chunk_count+1; v_position:=v_position+p_chunk_size-p_overlap; END LOOP; RETURN v_chunk_count; END; $$ LANGUAGE plpgsql;
CREATE POLICY "Users can view chunks for accessible documents" ON document_chunks FOR SELECT TO authenticated USING(EXISTS(SELECT 1 FROM documents d WHERE d.id=document_id AND(d.owner_id=auth.uid() OR EXISTS(SELECT 1 FROM document_access da WHERE da.document_id=d.id AND da.user_id=auth.uid()))));
CREATE POLICY "System can insert chunks" ON document_chunks FOR INSERT TO authenticated WITH CHECK(EXISTS(SELECT 1 FROM documents d WHERE d.id=document_id AND d.owner_id=auth.uid()));
CREATE POLICY "System can update chunks" ON document_chunks FOR UPDATE TO authenticated USING(EXISTS(SELECT 1 FROM documents d WHERE d.id=document_id AND d.owner_id=auth.uid())) WITH CHECK(EXISTS(SELECT 1 FROM documents d WHERE d.id=document_id AND d.owner_id=auth.uid()));
CREATE POLICY "System can delete chunks" ON document_chunks FOR DELETE TO authenticated USING(EXISTS(SELECT 1 FROM documents d WHERE d.id=document_id AND d.owner_id=auth.uid()));
CREATE POLICY "Users can view embeddings for accessible chunks" ON chunk_embeddings FOR SELECT TO authenticated USING(EXISTS(SELECT 1 FROM document_chunks dc JOIN documents d ON d.id=dc.document_id WHERE dc.id=chunk_id AND(d.owner_id=auth.uid() OR EXISTS(SELECT 1 FROM document_access da WHERE da.document_id=d.id AND da.user_id=auth.uid()))));
CREATE POLICY "System can insert embeddings" ON chunk_embeddings FOR INSERT TO authenticated WITH CHECK(EXISTS(SELECT 1 FROM document_chunks dc JOIN documents d ON d.id=dc.document_id WHERE dc.id=chunk_id AND d.owner_id=auth.uid()));
CREATE POLICY "System can update embeddings" ON chunk_embeddings FOR UPDATE TO authenticated USING(EXISTS(SELECT 1 FROM document_chunks dc JOIN documents d ON d.id=dc.document_id WHERE dc.id=chunk_id AND d.owner_id=auth.uid())) WITH CHECK(EXISTS(SELECT 1 FROM document_chunks dc JOIN documents d ON d.id=dc.document_id WHERE dc.id=chunk_id AND d.owner_id=auth.uid()));
CREATE OR REPLACE VIEW document_chunk_stats AS SELECT d.id as document_id, d.title as document_name, COUNT(dc.id) as chunk_count, SUM(dc.char_count) as total_chars, SUM(dc.token_count) as total_tokens, COUNT(ce.id) as embedded_chunks, ROUND(100.0*COUNT(ce.id)/NULLIF(COUNT(dc.id),0),2) as embedding_percentage FROM documents d LEFT JOIN document_chunks dc ON dc.document_id=d.id LEFT JOIN chunk_embeddings ce ON ce.chunk_id=dc.id GROUP BY d.id, d.title;
GRANT SELECT ON document_chunk_stats TO authenticated;
CREATE OR REPLACE VIEW embedding_search_performance AS SELECT COUNT(*) as total_embeddings, AVG(LENGTH(embedding::text)) as avg_embedding_size, pg_size_pretty(pg_total_relation_size('chunk_embeddings')) as table_size, pg_size_pretty(pg_indexes_size('chunk_embeddings')) as index_size FROM chunk_embeddings;
GRANT SELECT ON embedding_search_performance TO authenticated;
